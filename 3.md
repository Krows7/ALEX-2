# Чекпоинт №3

# Система планирования действий

## **1. Изначальная постановка задачи**

Первоначальная цель данного модуля состояла в создании системы, которая

1. Принимает пользовательский запрос (например: «мне нужна алмазная кирка» или «сделай кварцевые кирпичи»).
2. Определяет, какой предмет является целью.
3. Строит детальный пошаговый план, как эту цель достичь, то есть

   - что добыть,
   - что переплавить,
   - что скрафтить,
   - какие инструменты нужны и в каком порядке.

Изначально предполагалось, что всю эту работу будет делать дообученная GPT-2, и планировалось:

1. собрать датасет крафтов и инструкций,
2. дообучить GPT-2,
3. использовать LLM как единственный компонент, выполняющий и классификацию, и планирование.

---

## **2. Первая реализация и возникшие проблемы**

Изначально план был следующий:

- собрать большой датасет (пары _goal → steps_);
- обучить GPT-2 воспроизводить пошаговые планы;
- заставить модель опираться на рецепты и структуру мира.

Однако при тестировании возникли фундаментальные проблемы.

### **Проблема 1**

GPT-2 периодически добавляла:

- лишние предметы;
- несуществующие шаги;
- неправильное количество ресурсов;
- неправильный порядок действий;
- дублирование одного и того же шага множество раз;

### **Проблема 2**

Модель могла:

- пытаться добыть алмаз каменной киркой;
- забывать про изначальные ресурсы;
- пытаться крафтить золотую кирку, потому что, судя по всему, ей добывать удобнее;
- пытаться засадить огород или убить моба при запросе крафта печки;

### **Проблема 3**

STEVE-1 принимает только фиксированные базовые действия, а LLM не гарантировала

- что действия будут из whitelist;
- что они будут детерминированы;
- что не появится «построить дом», «создать портал» и т.п;
- что действия будут окончательными;

Насчет последнего поясню, LLM (по крайней мере GPT-2 без генеративного трансформера, преанализа и прочего) не понимает такого "ивента", как "достижение цели" и продолжает генерацию, даже если все уже сделано, либо наоборот обрывался раньше, потому что после данного шага чаще всего идет конец.

### **К чему мы пришли после данных выводов**

> Использовать LLM как полноценный планировщик - нестабильный, недетерминированный и трудно контролируемый компонент.

---

## **3. Смена архитектуры**

Было принято решение полностью перестроить систему:

1. Множество Minecraft-данных переносятся в граф зависимостей (CRAFT / MINE / SMELT).
2. Детерминированный планировщик разбирает цель на шаги.
3. Классификатор (embedding-based) определяет, что именно хочет пользователь.

---

## **4. Загрузка и нормализация данных Minecraft**

В качестве источника данных использован проект:

> **[PrismarineJS / minecraft-data](https://github.com/PrismarineJS/minecraft-data/tree/master)**

Загружены:

| Файл                                 | Назначение                                                                |
| ------------------------------------ | ------------------------------------------------------------------------- |
| `recipes.json`                       | рецепты крафта                                                            |
| `items.json`                         | полная база предметов                                                     |
| `blocks.json`                        | информация о блоках, дропа, прочности                                     |
| `materials.json`, `instruments.json` | второстепенные таблицы                                                    |
| `language.json`                      | локализация (к сожалению, пока не использовалась и не оправдала ожидания) |

На их основе построена собственная единая база действий (`actions_db.json`).

---

## **5. Генерация базы действий**

Созданы **три типа действий**:

### **1. MINE**

- берётся каждый diggable-блок,
- дропы извлекаются из `blocks.json`,
- корректно учитывается Minecraft-логика, связанная с рудами, а точнее

```
iron_ore → raw_iron
gold_ore → raw_gold
diamond_ore → diamond
```

Структура таких данных следующая:

```json
{
	"id": "MINE:cobbled_deepslate_slab",
	"kind": "MINE",
	"result": "cobbled_deepslate_slab",
	"requires_tool": "wooden_pickaxe"
}
```

### **2. SMELT**

Добавлены правила Minecraft:

- `raw_* → *_ingot`
- `sand → glass`
- `cobblestone → stone`
- `clay_ball → brick`

Структура таких данных следующая:

```json
  {
    "id": "SMELT:raw_iron->iron_ingot",
    "kind": "SMELT",
    "input": "raw_iron",
    "result": "iron_ingot"
  },
```

### **3. CRAFT**

- автоматически парсятся все рецепты,
- корректно подсчитываются ингредиенты,
- добавляются требования (`requires`):

  - `crafting_table`
  - `furnace`.

**Циклы (например, diamond → diamond_block → diamond) были автоматически обнаружены и исключены.**

Структура таких данных следующая:

```json
  {
    "id": "CRAFT:black_bed:6",
    "kind": "CRAFT",
    "result": "black_bed",
    "inputs": [
      {
        "item": "black_wool",
        "count": 3
      },
      {
        "any_of": [
          "oak_planks",
          "spruce_planks",
          "birch_planks",
          "jungle_planks",
          "acacia_planks",
          "cherry_planks",
          "dark_oak_planks",
          "pale_oak_planks",
          "mangrove_planks",
          "bamboo_planks",
          "crimson_planks",
          "warped_planks"
        ],
        "count": 3
      }
    ],
    "count": 1
  },
```

---

## **6. Классификация предметов**

Каждый предмет получил класс:

- **GOAL** — то, что пользователь реально хочет
  (мотыги, кирки, броня, сундук, верстак)
- **RESOURCE** — то, что добывается или является базовым ресурсом
  (бревно, руда, доска)
- **INTERMEDIATE** — ингредиенты
  (слитки, палки, камень)

---

## **7. Построение графа зависимостей**

Построен граф вида:

```
item → [actions которые могут его произвести]
action → [inputs]
```

Учтено:

- отсутствие циклов,
- поддержка действий ИЛИ («палки можно из любых досок»),
- автоматическое объединение эквивалентных ресурсов (plank → stick),
- приведение всех видов дерева к единой операции:

  ```
  ANY_LOG → ANY_PLANK → stick
  ```

---

## **8. Детерминированный планировщик**

Создан собственный рекурсивный planner, который:

- берёт желаемый предмет (например, diamond_pickaxe),
- вычисляет минимальный путь:

```
CHOP tree
CRAFT planks
CRAFT stick
CRAFT wooden_pickaxe
MINE cobblestone
CRAFT stone_pickaxe
MINE raw_iron
SMELT raw_iron → iron_ingot
CRAFT iron_pickaxe
MINE diamond
CRAFT diamond_pickaxe
```

---

## **9. Классификация пользовательских запросов**

### Что было сделано

1. Создано описание каждого GOAL-предмета.
2. Построены эмбеддинги (`multilingual-e5-base`).
3. Реализована функция:

   ```
   запрос → ближайший предмет
   ```

Работает стабильно на английском.

### Что НЕ получилось

Попытка использовать

- NLLB
- M2M100
- OPUS-MT

для мультиязычного перевода дала непредсказуемые результаты, к примеру перевод в ring / curtain / window при запросе кирки.

Причина:

> краткие доменные запросы плохо переводятся общими MT-моделями.

Поэтому перевод с других языков отключён полностью (надеюсь, что пока что).

---

## **10. Полученный результат**

Сформирована полноценная система:

### **Компоненты:**

- генератор действий (`actions_db.json`);
- граф зависимостей;
- детерминированный планировщик;
- классификатор цели (эмбеддинги);
- нормализатор запросов;
- CLI-интерфейс для взаимодействия.

### **Система способна:**

- понять запрос пользователя,
- корректно выбрать предмет,
- построить по нему план,
- гарантировать правильную последовательность действий для STEVE-1.

---
